import streamlit as st
import pandas as pd
import utils

df = pd.read_csv('data/telco_customer_churn_clean.csv')

st.title('Predicting Customer Churn for Subscription Service')

st.markdown("""
According to several sources ([1](https://ordwaylabs.com/resources/guides/subscription-billing-guide/#:~:text=Subscription%20billing%20is%20a%20key,processed%20through%20subscription%20billing%20platforms.)), nearly 60% of digital companies use subscription services as part of their business model.
For some of the fastest-growing companies like Netflix, Spotify, Microsoft and Google, subscription billing has been key to this expansion.
It should come as no surprise that these same companies are actively building machine learning models to predict which customers are likely to cancel their subscriptions and when.
            
With open-sourced subscription data published by sites like [Kaggle](https://www.kaggle.com/) and [GitHub](https://github.com/), I have trained my own churn-prediction system based on the telecommuncations company, **Telco**, an imaginary subsidiary of IBM.
This applet allows you to predict whether generated customer profiles are likely to churn in the next month. You can select from several optimized models including the best [Gradient Boosting]() model to make a prediction. 
I was inspired by this [article on Bagging, Boosting and Stacking Techniques](https://www.baeldung.com/cs/bagging-boosting-stacking-ml-ensemble-models#:~:text=Boosting%20trains%20multiple%20homogenous%20weak,to%20obtain%20a%20meta%2Dmodel) that discusses the benefits of using XGBoost, CatBoost, and LightGBM gradient boosting algorithms for capturing complex relationships and handling imbalanced data found in our subscriptions dataset.


### How to use:
1. Edit customer profile and click on the "Generate" button to create a new customer
2. Select your choice of ML model
3. Click on the "Will they churn?" button to make a churn prediction for this customer

**Note:** All customer data is generated by aggregating random samples from each feature according to the distribution found in the original subscriptions dataset.
No real private customer data is used in this application or in the original dataset.
            
##### Resources:
- Subscriptions Dataset from Kaggle: 
- Code Source from GitHub: 

            
""")

st.button('Generate')

def build_a_customer():

    st.sidebar.markdown("## Build a subscriber profile:")

    st.sidebar.image("https://thispersondoesnotexist.com/", width=256, output_format="JPEG")

    st.sidebar.markdown("### Lifetime Value (LTV):")

    tenure_range = (0, 100)
    tenure = st.sidebar.slider("Months Subscribed", *tenure_range, 12)
    tenure_binned = utils.bin_value(*tenure_range, tenure)
    monthlycharges_range = (0, 50)
    monthlycharges = st.sidebar.slider("Monthly Charges (in USD)", *monthlycharges_range, 25)
    monthlycharges_binned = utils.bin_value(*monthlycharges_range, monthlycharges)
    totalcharges = monthlycharges * tenure
    totalcharges_binned = "Low" # Edit later
    st.sidebar.markdown(f"Total LTV:\t**${totalcharges:.2f}**")

    # Subscriber Characteristics
    st.sidebar.markdown("---\n### Customer Persona:")

    name = st.sidebar.text_input('Full Name', "Jane Doe")
    gender = st.sidebar.radio('Gender', ("Male", "Female"))
    senior_citizen = st.sidebar.radio('Senior Citizen', ('Yes', 'No'))
    partner = st.sidebar.radio('Partner', ('Yes', 'No'))
    dependents = st.sidebar.radio('Dependents', ('Yes', 'No'))

    st.sidebar.markdown("---\n### Services:")
    
    # Phone service details
    phone_service = st.sidebar.radio('Has Phone Service', ('Yes', 'No'))
    if phone_service == 'Yes':
        multiple_lines = st.sidebar.radio('Has Multiple Phone Lines', ('Yes', 'No'))
    else:
        multiple_lines = 'No phone service'
    
    # Internet service details
    internet_service_type = st.sidebar.selectbox('Type of Internet Service', ('DSL', 'Fiber optic', 'No'))
    if internet_service_type != 'No':
        online_security = st.sidebar.radio('Has Online Security', ('Yes', 'No'))
        online_backup = st.sidebar.radio('Has Online Backup', ('Yes', 'No'))
        device_protection = st.sidebar.radio('Has Device Protection', ('Yes', 'No'))
        tech_support = st.sidebar.radio('Has Technical Support', ('Yes', 'No'))
        streaming_tv = st.sidebar.radio('Has TV Streaming', ('Yes', 'No'))
        streaming_movies = st.sidebar.radio('Has Movie Streaming', ('Yes', 'No'))
    else:
        online_security = 'No internet service'
        online_backup = 'No internet service'
        device_protection = 'No internet service'
        tech_support = 'No internet service'
        streaming_tv = 'No internet service'
        streaming_movies = 'No internet service'

    st.sidebar.markdown("---\n### Payment Details:")
    contract = st.sidebar.selectbox('Contract Term', ('Month-to-month', 'One year', 'Two year'))
    payment_method = st.sidebar.selectbox('Payment Method', (
        'Bank transfer (automatic)', 'Credit card (automatic)', 'Mailed check', 'Electronic check'))
    paperless_billing = st.sidebar.radio('Has Paperless Billing', ('Yes', 'No'))

    # Create new fake user
    return pd.DataFrame({
        'gender': [gender],
        'SeniorCitizen': [1 if senior_citizen.lower() == 'yes' else 0],
        'Partner': [partner],
        'Dependents': [dependents],
        'PhoneService': [phone_service],
        'MultipleLines': [multiple_lines],
        'InternetService': [internet_service_type],
        'OnlineSecurity': [online_security],
        'OnlineBackup': [online_backup],
        'DeviceProtection': [device_protection],
        'TechSupport': [tech_support],
        'StreamingTV': [streaming_tv],
        'StreamingMovies': [streaming_movies],
        'Contract': [contract],
        'PaperlessBilling': [paperless_billing],
        'PaymentMethod': [payment_method],
        'tenure-binned': [tenure_binned],
        'MonthlyCharges-binned': [monthlycharges_binned],
        'TotalCharges-binned': [totalcharges_binned],
    })

fake_customer_df = build_a_customer()

# To implement basic inference:
# [ ] Encode fake_customer categories based on encoding for X_train
# [ ] Retrieve model
# [ ] Make prediction using predict_proba() on click

# For advanced inference:
# [ ] Allow user to select model
# [ ] Generate fake customer by sampling features from X_train distribution
# [ ] Add fake customer examples

churn = st.sidebar.button("Will they churn?")